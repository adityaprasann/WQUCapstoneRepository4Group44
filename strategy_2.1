from __future__ import (absolute_import, division, print_function,unicode_literals)
import datetime  # For datetime objects
import os.path  # To manage paths
import sys  # To find out the script name (in argv[0])
# Import the backtrader platform
import backtrader as bt
import backtrader.indicators as btind
import pandas as pd
from pandas import Series, DataFrame
import random
from copy import deepcopy
# Create a Stratey
class SMAC(bt.Strategy):
    """A simple moving average crossover strategy; crossing of a fast and slow moving average generates buy/sell
       signals"""
    params = {"trix": 3, "variable1":0.4 ,# The windows for both fast and slow moving averages
              "optim": False, "optim_variable": (3,.4)}  # Used for optimization; equivalent of fast and slow, but a tuple
    def __init__(self):
        """Initialize the strategy"""
        self.order = None
        self.buyprice = None
        self.buycomm = None
        self.dataclose = dict()
        self.dataopen=dict()
        self.datahigh = dict()
        self.datalow = dict()
        self.trix = dict()
        #self.sma = dict()
        self.bband = dict()

        if self.params.optim:  # Use a tuple during optimization
            self.params.trix,self.params.variable1 = self.params.optim_variable  # fast and slow replaced by tuple's contents

        # if self.params.fast > self.params.slow:
        #     raise ValueError(
        #         "A SMAC strategy cannot have the fast moving average's window be " + \
        #         "greater than the slow moving average window.")

        for d in self.getdatanames():
            # The moving averages
            self.dataclose[d] = self.getdatabyname(d).close
            self.dataopen[d] = self.getdatabyname(d).open
            self.datahigh[d] = self.getdatabyname(d).high
            self.datalow[d] = self.getdatabyname(d).low
            self.trix[d] =  btind.TRIX(self.getdatabyname(d), period=self.params.trix, plotname="trix: " + d)
            #self.bband[d] = btind.BBands(self.getdatabyname(d), period=self.params.bband)
            # Get the regime
            #self.regime[d] = self.fastma[d] - self.slowma[d]  # Positive when bullish
        self.trade_list = []

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Active Buy/Sell order submitted/accepted - Nothing to do
            return
        # Check if an order has been completed
        # Attention: broker could reject order if not enough cash
        if order.status in [order.Completed]:
            #print(order)
            if order.isbuy():
                self.log('BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %(order.executed.price,order.executed.value,order.executed.comm))
                trade_dictionary = {"time":self.datas[0].datetime.datetime(0) ,"stock": order.data._name,"qty":order.size ,
                                 #  "1":order.ref,"2": order.getstatusname(),
                                    "trade": "BUY", "Entry_price": order.executed.price,
                                    }
                self.trade_list.append(trade_dictionary)
            elif order.issell():
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %(order.executed.price,order.executed.value,order.executed.comm))
                trade_dictionary = {"time":self.datas[0].datetime.datetime(0),"stock": order.data._name, "qty":order.size,
                                  #  "1":order.ref,"2": order.getstatusname(),
                                    "trade": "SELL", "Entry_price": order.executed.price,
                                    }
                self.trade_list.append(trade_dictionary)
            self.bar_executed = len(self)
        elif order.status in [order.Canceled, order.Margin, order.Rejected]:
            self.log('Order Canceled/Margin/Rejected')
            # Reset orders
        self.order = None

    def notify_trade(self, trade):
        if trade.isclosed:
            self.log('TRADE PROFIT, GROSS %.2f, NET %.2f' %(trade.pnl, trade.pnlcomm))

        elif trade.justopened:
            self.log('TRADE OPENED, SIZE %2d' % trade.size)

    def log(self, txt, dt=None):
        dt = dt or self.datas[0].datetime.datetime(0)
        print('%s, %s' % (dt.isoformat(), txt))  # Print date and close
        # print(cerebro.broker.getvalue())
    def next(self):

        """Define what will be done in a single step, including creating and closing trades"""
        for d in self.getdatanames():  # Looping through all symbols
            #print(self.bband[d][0])
            pos = self.getpositionbyname(d).size or 0
            if pos == 0:  # Are we out of the market?
                if self.dataclose[d][0] > self.dataopen[d][0] and self.dataclose[d][-1] > self.dataopen[d][-1]  and \
                    self.dataclose[d][-2] > self.dataopen[d][-2] and self.trix[d][0] > 0 and \
                        (self.dataclose[d][0] - self.dataopen[d][0]) >self.params.variable1*(self.datahigh[d][0] - self.datalow[d][0]) :# A buy signal
                    #self.buy(data=self.getdatabyname(d) , size = round(100000/ self.getdatabyname(d).close ,0))
                    self.buy(data=self.getdatabyname(d),histnotify=True)

                if self.dataopen[d][0]>self.dataclose[d][0] and self.dataopen[d][-1]>self.dataclose[d][-1] and \
                        self.dataopen[d][-2]>self.dataclose[d][-2] and \
                        self.trix[d][0] < 0 and (self.dataopen[d][0] - self.dataclose[d][0]) >self.params.variable1*(self.datahigh[d][0] - self.datalow[d][0]) :  # A sell signal and self.datahigh[d][0]<self.dataclose[d][-1]
                    self.sell(data=self.getdatabyname(d),histnotify=True)
            else:  # We have an open position
                #print(pos)
                if pos > 0:
                    if self.trix[d][0] < 0:  # A sell signal
                        #self.sell(data=self.getdatabyname(d),  size = round(100000/ self.getdatabyname(d).close ,0))
                        self.sell(data=self.getdatabyname(d),size =abs(pos),histnotify=True)
                if pos < 0:
                    if self.trix[d][0] > 0:  # A sell signal
                        #self.sell(data=self.getdatabyname(d),  size = round(100000/ self.getdatabyname(d).close ,0))
                        self.buy(data=self.getdatabyname(d),size =abs(pos),histnotify=True)

    def stop(self):
        print('Starting Value - %.2f' % self.broker.startingcash)
        print('Ending   Value - %.2f' % self.broker.getvalue())
        # Following is code for printing each stock tradesheet, but only successful in case of only one run at a time (i.e. only 1 set of parameters)
        #print(type(self._trades))   # <class 'collections.defaultdict'>
        #print(type(self._orders))     #<class 'list'>
        # for d in self.getdatanames():
        #    trade_list1= []
        #    data_trades = self._trades[self.getdatabyname(d)][0]
        #    #print(data_trades[0])
        #    for record in data_trades:
        #        trade_dictionary = {"stock":d,"entry_time": record.dtopen,"exit_time": record.dtclose, "is_open": record.isopen,
        #                             "time_dur": record.barlen,"price": record.price,"pnl":record.pnl, "pnl_ac": record.pnlcomm,
        #                            }
        #        trade_list1.append(trade_dictionary)
        #    tradesheet=pd.DataFrame(trade_list1)
        #    tradesheet.to_csv(d+"_tradesheet.csv",index=False)
class AcctValue(bt.Observer):
    def __init__(self):
        self.equity_value_list = []
    alias = ('Value',)
    lines = ('value',)
    plotinfo = {"plot": True, "subplot": True}
    def next(self):
        self.lines.value[0] = self._owner.broker.getvalue()  # Get today's account value (cash + stocks)
        #print(self.lines.value[0])
        #print(self.lines.value[3])
        equity_value_dictionary = {"time": self.datas[0].datetime.datetime(0), "equity_value":self.lines.value[0],
                            }
        self.equity_value_list.append(equity_value_dictionary)
    def get_equity_value(self):
        return pd.DataFrame(self.equity_value_list)

class AcctStats(bt.Analyzer):
    """A simple analyzer that gets the gain in the value of the account; should be self-explanatory"""
    def __init__(self):
        self.start_val = self.strategy.broker.get_value()
        self.end_val = None
    def stop(self):
        self.end_val = self.strategy.broker.get_value()
    def get_analysis(self):
        return {"start": self.start_val, "end": self.end_val,"growth": self.end_val - self.start_val, "return": self.end_val / self.start_val}

class PropSizer(bt.Sizer):
    """A position sizer that will buy as many stocks as necessary for a certain proportion of the portfolio
       to be committed to the position, while allowing stocks to be bought in batches (say, 100)"""
    params = {"prop": 0.02, "batch": 100}
    def _getsizing(self, comminfo, cash, data, isbuy):
        """Returns the proper sizing"""
        #if isbuy:  # Buying
        target = self.broker.getvalue() * self.params.prop  # Ideal total value of the position
        price = data.close[0]
        #shares_ideal = target / price  # How many shares are needed to get target
        #batches = int(shares_ideal / self.params.batch)  # How many batches is this trade?
        #shares = batches * self.params.batch  # The actual number of shares bought
        shares = int(target / price)
        if shares * price > cash:
            return 0  # Not enough money for this trade
        else:
            return shares
        # return self.broker.getposition(data).size  # Clear the position

if __name__ == '__main__':
    start = datetime.datetime(2017, 8, 1)
    end = datetime.datetime(2020, 4, 30)
    is_first = True
    # Create a cerebro entity
    cerebro = bt.Cerebro(stdstats=False,optreturn=False)  # I don't want the default plot objects  maxcpus=1,writer=True,
    cerebro.broker.set_coc(True) # this will take trade on current bar close
    # if you use maxcpus=1 then process will be slow, if not used then process will be faster, with not using it you cant do writer=True,
    #i ran 2 set of parameters, with maxcpus=1 it took 4.5 min otherwise it took 3 min
    # Not the same set of symbols as in other blog posts
    symbols = ['adaniports_15min.csv', 'asianpaint_15min.csv', 'axisbank_15min.csv', 'bajajfinsv_15min.csv', 'bajaj_auto_15min.csv',
               'bajfinance_15min.csv', 'bhartiartl_15min.csv', 'bpcl_15min.csv', 'britannia_15min.csv', 'cipla_15min.csv',
               'coalindia_15min.csv', 'drreddy_15min.csv', 'eichermot_15min.csv', 'gail_15min.csv', 'grasim_15min.csv',
               'hcltech_15min.csv', 'hdfcbank_15min.csv', 'hdfc_15min.csv', 'heromotoco_15min.csv', 'hindalco_15min.csv',
               'hindunilvr_15min.csv', 'icicibank_15min.csv', 'indusindbk_15min.csv', 'infratel_15min.csv', 'infy_15min.csv',
               'ioc_15min.csv', 'itc_15min.csv', 'jswsteel_15min.csv', 'kotakbank_15min.csv', 'lt_15min.csv', 'maruti_15min.csv',
               'mm_15min.csv', 'nestleind_15min.csv', 'ntpc_15min.csv', 'ongc_15min.csv', 'powergrid_15min.csv', 'reliance_15min.csv',
               'sbin_15min.csv', 'sunpharma_15min.csv', 'tatamotors_15min.csv', 'tatasteel_15min.csv', 'tcs_15min.csv', 'techm_15min.csv',
               'titan_15min.csv', 'ultracemco_15min.csv', 'upl_15min.csv', 'vedl_15min.csv', 'wipro_15min.csv', 'zeel_15min.csv']
    #symbols = ['adaniports_15min.csv','asianpaint_15min.csv']   #,'asianpaint_15min.csv'
    plot_symbols = symbols
    for s in symbols:
        data = bt.feeds.GenericCSVData(dataname=s,
                                       fromdate=start,todate=end,
                                       datetime=0, open=1, high=2, low=3, close=4,
                                       volume=5, openinterest=-1, timeframe=bt.TimeFrame.Ticks,
                                       dtformat="%Y-%m-%d %H:%M:%S",
                                       # tmformat='%H:%M',     sessionstart=sessionstart
                                       )
        if s in plot_symbols:
            if is_first:
                data_main_plot = data
                is_first = False
            else:
                data.plotinfo.plotmaster = data_main_plot
        else:
            data.plotinfo.plot = False
        cerebro.adddata(data)  # Give the data to cerebro
    # Generate random combinations of fast and slow window lengths to test
    windowset = set()
    l_array = [3, 5, 9]
    #s_array = [3, 5, 9,14,21]
    n_array = [0.3,0.4,0.5,0.6]
    for l in l_array:
        #for s in s_array:
            for n in n_array:
                # if s > l:  # Cannot have the fast moving average have a longer window than the slow, so swap
                #     l, s = s, l
                #     windowset.add((l, s, l, s, n))
                # elif l == s:  # Cannot be equal, so do nothing, discarding results
                #     pass
                # else:
                #     windowset.add((l, s, l, s, n))
                windowset.add((l, n))
    windows = list(windowset)
    #windows = windows[:2]
    # windows = [(5,5,9, 3, 1.03), (9,5,9, 5, 1.03)]
    print("len is ", len(windows), windows)
    #windows = [(9, 3, 1.03), (9, 5, 1.03), (9, 3, 1.04),(9, 5, 1.04)]
    cerebro.addobserver(AcctValue)
    cerebro.addanalyzer(AcctStats)
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name='sharpe_ratio')
    cerebro.addanalyzer(bt.analyzers.SQN, _name='SQN')
    cerebro.addanalyzer(bt.analyzers.TradeAnalyzer, _name='TradeAnalyzer')
    cerebro.addanalyzer(bt.analyzers.DrawDown, _name='DrawDown')
    cerebro.addanalyzer(bt.analyzers.Transactions, _name='Transactions')

    #cerebro.addstrategy(SMAC)
    cerebro.optstrategy(SMAC,optim=True, optim_variable=windows )#  optim=False, optim_variable=windows
    #cerebro.addsizer(bt.sizers.FixedSize, stake=10)  # Add a FixedSize sizer according to the stake
    cerebro.addsizer(PropSizer)   # Add a Variable sizer
    # Set our desired cash start
    cerebro.broker.setcash(2500000.0)
    # Set the commission
    cerebro.broker.setcommission(commission=0.0001)
    #cerebro.add_order_history(orders, notify=True)
    # Print out the starting conditions
    #print('Starting Portfolio Value: %.2f' % cerebro.broker.getvalue())
    # Run over everything
    res = cerebro.run()
    list1=[]
    for strat in res:
        # this is first way of creating tradesheet, trade_list is made by recording each transaction in notify_order function
        df_tradesheet = pd.DataFrame(strat[0].trade_list)
        df_tradesheet.to_csv(str(strat[0].params.optim_variable) + "_tradesheet.csv", index=False)
        sharpe = strat[0].analyzers.sharpe_ratio.get_analysis()
        sq = strat[0].analyzers.SQN.get_analysis()
        ta = strat[0].analyzers.TradeAnalyzer.get_analysis()
        retur_perc = strat[0].analyzers.acctstats.get_analysis()
        drawdown = strat[0].analyzers.DrawDown.get_analysis()
        transactions1 = strat[0].analyzers.Transactions.get_analysis()   # its ordered dictionary
        # this is second way of creating tradesheet, by adding analyzer class Transactions
        tradesheet_list = []
        for key in transactions1.keys():
            transactions_dict = {"Stock": transactions1[key][0][3], "Entry_time": key,"Entry_Price": transactions1[key][0][1],
                                 "qty": transactions1[key][0][0], "value": transactions1[key][0][4]} # print a value from key and see what all is thr
            tradesheet_list.append(transactions_dict)
        name_of_run = '_'.join([str(x) for x in strat[0].params.optim_variable])  #to convert from tuple of int to list of string
        pd.DataFrame(tradesheet_list).to_csv("1_"+name_of_run+"_tradesheet_combined.csv",index=False)
        #print(ta.keys())  # there are many stats in this, nested dictionaries explore more in this
        stats_summary = {"run_name": name_of_run,"end": str(retur_perc['end']),"growth": str(retur_perc['growth']),
                            "return": str(retur_perc['return']),"sharpe": str(sharpe['sharperatio']),"SQN":str(sq["sqn"]),
                        "Trades":str(sq["trades"]) ,
                         "open_trades": str(ta['total']['open']) ,
                         "average_pnl": str(ta['pnl']['net']['average']) ,
                         "won_trades": str(ta['won']['total']) ,
                         "loss_trades": str(ta['lost']['total']) ,
                         "long_trades": str(ta['long']['total']) ,"short_trades": str(ta['short']['total']) ,
                        "max_DD": str(drawdown['max']['moneydown'])
                         }
        list1.append(stats_summary)

    summary = pd.DataFrame(list1)
    summary.to_csv("1_summary.csv", index=False)  # summary of all runs
    #return_opt = DataFrame({r[0].params.optim_variable: r[0].analyzers.acctstats.get_analysis() for r in res}).T.loc[:, ['end', 'growth', 'return']]
    #return_opt.to_csv("summary.csv", index=True)

    # Print out the final result
    #print('Final Portfolio Value: %.2f' % cerebro.broker.getvalue())
    # Plot the result
    #cerebro.plot(iplot=True, volume=False)
